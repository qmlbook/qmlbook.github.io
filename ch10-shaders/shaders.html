<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
        <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>10. Shader Effects &#8212; Qt5 Cadaques Book vmaster</title>
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/custom-styles.css" type="text/css" />
    <script type="text/javascript" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="11. Multimedia" href="../ch11-multimedia/multimedia.html" />
    <link rel="prev" title="9. Particle Simulations" href="../ch09-particles/particles.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../_static/bootstrap-sphinx.js "></script>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html">
          QmlBook</a>
        <span class="navbar-text navbar-version pull-left"><b>master</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html">Chapters <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../ch01-meetqt/meetqt.html">1. Meet Qt 5</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ch02-start/start.html">2. Get Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ch03-qtcreator/qtcreator.html">3. Qt Creator IDE</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ch04-qmlstart/qmlstart.html">4. Quick Starter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ch05-fluid/fluid.html">5. Fluid Elements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ch06-controls/controls.html">6. Qt Quick Controls 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ch07-modelview/modelview.html">7. Model-View-Delegate</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ch08-canvas/canvas.html">8. Canvas Element</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ch09-particles/particles.html">9. Particle Simulations</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">10. Shader Effects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ch11-multimedia/multimedia.html">11. Multimedia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ch12-networking/networking.html">12. Networking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ch13-storage/storage.html">13. Storage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ch14-dynamicqml/dynamicqml.html">14. Dynamic QML</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ch15-javascript/javascript.html">15. JavaScript</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ch16-qtcpp/qtcpp.html">16. Qt and C++</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ch17-extensions/extensions.html">17. Extending QML with C++</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ch18-python/python.html">18. Qt for Python</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../testing/testing.html">1. Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../deployment/deployment.html">2. Deploying QML Applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../draganddrop/draganddrop.html">3. Drag and Drop</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">10. Shader Effects</a><ul>
<li><a class="reference internal" href="#opengl-shaders">10.1. OpenGL Shaders</a></li>
<li><a class="reference internal" href="#shader-elements">10.2. Shader Elements</a></li>
<li><a class="reference internal" href="#fragment-shaders">10.3. Fragment Shaders</a></li>
<li><a class="reference internal" href="#wave-effect">10.4. Wave Effect</a></li>
<li><a class="reference internal" href="#vertex-shader">10.5. Vertex Shader</a></li>
<li><a class="reference internal" href="#curtain-effect">10.6. Curtain Effect</a></li>
<li><a class="reference internal" href="#qt-graphicseffect-library">10.7. Qt GraphicsEffect Library</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
  <li>
    <a href="../ch09-particles/particles.html" title="Previous Chapter: 9. Particle Simulations"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm hidden-tablet">&laquo; 9. Particle S...</span>
    </a>
  </li>
  <li>
    <a href="../ch11-multimedia/multimedia.html" title="Next Chapter: 11. Multimedia"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm hidden-tablet">11. Multimedia &raquo;</span>
    </a>
  </li>
              
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="col-md-3">
        <div id="sidebar" class="bs-sidenav" role="complementary"><ul>
<li><a class="reference internal" href="#">10. Shader Effects</a><ul>
<li><a class="reference internal" href="#opengl-shaders">10.1. OpenGL Shaders</a></li>
<li><a class="reference internal" href="#shader-elements">10.2. Shader Elements</a></li>
<li><a class="reference internal" href="#fragment-shaders">10.3. Fragment Shaders</a></li>
<li><a class="reference internal" href="#wave-effect">10.4. Wave Effect</a></li>
<li><a class="reference internal" href="#vertex-shader">10.5. Vertex Shader</a></li>
<li><a class="reference internal" href="#curtain-effect">10.6. Curtain Effect</a></li>
<li><a class="reference internal" href="#qt-graphicseffect-library">10.7. Qt GraphicsEffect Library</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    <div class="body col-md-9 content" role="main">
      
  <div class="section" id="shader-effects">
<h1>10. Shader Effects<a class="headerlink" href="#shader-effects" title="Permalink to this headline">¶</a></h1>
<p><em>Section author: <a class="reference external" href="https://www.linkedin.com/in/jryannel">jryannel&#64;LinkedIn</a></em></p>
<p><div class="btn-group btn-group-justified" role="group"><a class="btn btn-primary btn-xs" href="https://github.com/qmlbook/qmlbook/" target="_blank">Github</a><a class="btn btn-primary btn-xs" href="https://github.com/qmlbook/qmlbook//blob/master/docs/ch10-shaders/shaders.rst" target="_blank"><i class="glyphicon glyphicon-file"></i> View</a><a class="btn btn-primary btn-xs" href="https://github.com/qmlbook/qmlbook//edit/master/docs/ch10-shaders/shaders.rst" target="_blank"><i class="glyphicon glyphicon-pencil"></i> Edit</a><a class="btn btn-primary btn-xs" href="https://github.com/qmlbook/qmlbook//issues/new?labels=ch10&body=back-link%3A+ch10-shaders%2Fshaders.html%23shader-effects" target="_blank"><i class="glyphicon glyphicon-plus"></i> Issue </a><a  class="btn btn-primary btn-xs" href="https://github.com/qmlbook/qmlbook//issues?labels=ch10&page=1&state=open" target="_blank"><i class="glyphicon glyphicon-search"></i> Issues</a></div></p><div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Last Build: July 18, 2020 at 13:03 CET</p>
<p class="last">The source code for this chapter can be found in the <a class="reference external" href="../assets">assets folder</a>.</p>
</div>
<div class="topic">
<p class="topic-title">Objective</p>
<ul class="simple">
<li><a class="reference external" href="http://doc.qt.io/qt-5/qml-qtquick-shadereffect.html">http://doc.qt.io/qt-5/qml-qtquick-shadereffect.html</a></li>
<li><a class="reference external" href="http://www.opengl.org/registry/doc/GLSLangSpec.4.20.6.clean.pdf">http://www.opengl.org/registry/doc/GLSLangSpec.4.20.6.clean.pdf</a></li>
<li><a class="reference external" href="http://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf">http://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf</a></li>
<li><a class="reference external" href="http://www.lighthouse3d.com/opengl/glsl/">http://www.lighthouse3d.com/opengl/glsl/</a></li>
<li><a class="reference external" href="http://wiki.delphigl.com/index.php/Tutorial_glsl">http://wiki.delphigl.com/index.php/Tutorial_glsl</a></li>
<li><a class="reference external" href="http://doc.qt.io/qt-5//qtquick-shaders.html">Qt5Doc qtquick-shaders</a></li>
</ul>
<p>Give a short introduction to shader effects and then present the shader effects and their use.</p>
</div>
<p>Shaders allow us to create awesome rendering effects on top of the SceneGraph API leveraging directly the power of OpenGL running on the GPU. Shaders are implemented using the ShaderEffect and ShaderEffectSource elements. The shader algorithm itself is implemented using the OpenGL Shading Language.</p>
<p>Practically it means you mix QML code with shader code. On execution will the shader code be sent over to the GPU and compiled and executed on the GPU. The shader QML elements allow you to interact through properties with the OpenGL shader implementation.</p>
<p>Let’s first have a look what OpenGL shaders are.</p>
<div class="section" id="opengl-shaders">
<h2>10.1. OpenGL Shaders<a class="headerlink" href="#opengl-shaders" title="Permalink to this headline">¶</a></h2>
<p><div class="btn-group" role="group"><a class="btn btn-link btn-xs" href="https://github.com/qmlbook/qmlbook//new?labels=ch09&body=back-link%3A+ch10-shaders%2Fshaders.html%23opengl-shaders"><i class="glyphicon glyphicon-plus"></i> Issue</a><a class="btn btn-link btn-xs" href="https://github.com/qmlbook/qmlbook/?labels=ch09&page=1&state=open"><i class="glyphicon glyphicon-search"></i> Issues</a></div></p><p>OpenGL uses a rendering pipeline split into stages. A simplified OpenGL pipeline would contain a vertex and fragment shader.</p>
<div class="figure align-center">
<img alt="../_images/openglpipeline.png" src="../_images/openglpipeline.png" />
</div>
<p>The vertex shader receives vertex data and must assign it to the <em>gl_Position</em> at the end of the routine. In the next stage, the vertexes are clipped, transformed and rasterized for pixel output. From there the fragments (pixels) arrive in the fragment shader and can further be manipulated and the resulting color needs to be assigned to <em>gl_FragColor</em>. The vertex shader is called for each corner point of your polygon (vertex = point in 3D) and is responsible for any 3D manipulation of these points. The fragment (fragment = pixel) shader is called for each pixel and determines the color of that pixel.</p>
</div>
<div class="section" id="shader-elements">
<h2>10.2. Shader Elements<a class="headerlink" href="#shader-elements" title="Permalink to this headline">¶</a></h2>
<p><div class="btn-group" role="group"><a class="btn btn-link btn-xs" href="https://github.com/qmlbook/qmlbook//new?labels=ch09&body=back-link%3A+ch10-shaders%2Fshaders.html%23shader-elements"><i class="glyphicon glyphicon-plus"></i> Issue</a><a class="btn btn-link btn-xs" href="https://github.com/qmlbook/qmlbook/?labels=ch09&page=1&state=open"><i class="glyphicon glyphicon-search"></i> Issues</a></div></p><p>For programming shaders, Qt Quick provides two elements. The ShaderEffectSource and the ShaderEffect. The shader effect applies custom shaders and the shader effect source renders a QML item into a texture and renders it. As shader effect can apply custom shaders to its rectangular shape and can use sources for the shader operation. A source can be an image, which is used as a texture or a shader effect source.</p>
<p>The default shader uses the source and renders it unmodified.</p>
<div class="highlight-qml notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nx">QtQuick</span> <span class="mf">2.5</span>

<span class="nx">Rectangle</span> <span class="p">{</span>
    <span class="k">width:</span> <span class="mi">480</span><span class="p">;</span> <span class="k">height:</span> <span class="mi">240</span>
    <span class="k">color:</span> <span class="s1">&#39;#1e1e1e&#39;</span>

    <span class="nx">Row</span> <span class="p">{</span>
        <span class="k">anchors.centerIn:</span> <span class="nx">parent</span>
        <span class="k">spacing:</span> <span class="mi">20</span>
        <span class="nx">Image</span> <span class="p">{</span>
            <span class="kd">id: sourceImage</span>
            <span class="k">width:</span> <span class="mi">80</span><span class="p">;</span> <span class="k">height:</span> <span class="nx">width</span>
            <span class="k">source:</span> <span class="s1">&#39;assets/tulips.jpg&#39;</span>
        <span class="p">}</span>
        <span class="nx">ShaderEffect</span> <span class="p">{</span>
            <span class="kd">id: effect</span>
            <span class="k">width:</span> <span class="mi">80</span><span class="p">;</span> <span class="k">height:</span> <span class="nx">width</span>
            <span class="nx">property</span> <span class="nx">variant</span> <span class="k">source:</span> <span class="nx">sourceImage</span>
        <span class="p">}</span>
        <span class="nx">ShaderEffect</span> <span class="p">{</span>
            <span class="kd">id: effect2</span>
            <span class="k">width:</span> <span class="mi">80</span><span class="p">;</span> <span class="k">height:</span> <span class="nx">width</span>
            <span class="c1">// the source where the effect shall be applied to</span>
            <span class="nx">property</span> <span class="nx">variant</span> <span class="k">source:</span> <span class="nx">sourceImage</span>
            <span class="c1">// default vertex shader code</span>
            <span class="k">vertexShader:</span> <span class="s2">&quot;</span>
<span class="s2">                uniform highp mat4 qt_Matrix;</span>
<span class="s2">                attribute highp vec4 qt_Vertex;</span>
<span class="s2">                attribute highp vec2 qt_MultiTexCoord0;</span>
<span class="s2">                varying highp vec2 qt_TexCoord0;</span>
<span class="s2">                void main() {</span>
<span class="s2">                    qt_TexCoord0 = qt_MultiTexCoord0;</span>
<span class="s2">                    gl_Position = qt_Matrix * qt_Vertex;</span>
<span class="s2">                }&quot;</span>
            <span class="c1">// default fragment shader code</span>
            <span class="k">fragmentShader:</span> <span class="s2">&quot;</span>
<span class="s2">                varying highp vec2 qt_TexCoord0;</span>
<span class="s2">                uniform sampler2D source;</span>
<span class="s2">                uniform lowp float qt_Opacity;</span>
<span class="s2">                void main() {</span>
<span class="s2">                    gl_FragColor = texture2D(source, qt_TexCoord0) * qt_Opacity;</span>
<span class="s2">                }&quot;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="figure">
<img alt="../_images/defaultshader.png" src="../_images/defaultshader.png" />
</div>
<p>In the above example, we have a row of 3 images. The first is the real image. The second is rendered using the default shader and the third is rendered using the default shader code for the fragment and vertex extracted from the Qt 5 source code.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you don’t want to see the source image and only the effected image you can set the <em>Image</em> to invisible (`` visible: false``). The shader effects will still use the image data just the <em>Image</em> element will not be rendered.</p>
</div>
<p>Let’s have a closer look at the shader code.</p>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="nx">vertexShader</span><span class="o">:</span> <span class="s2">&quot;</span>
<span class="s2">    uniform highp mat4 qt_Matrix;</span>
<span class="s2">    attribute highp vec4 qt_Vertex;</span>
<span class="s2">    attribute highp vec2 qt_MultiTexCoord0;</span>
<span class="s2">    varying highp vec2 qt_TexCoord0;</span>
<span class="s2">    void main() {</span>
<span class="s2">        qt_TexCoord0 = qt_MultiTexCoord0;</span>
<span class="s2">        gl_Position = qt_Matrix * qt_Vertex;</span>
<span class="s2">    }&quot;</span>
</pre></div>
</div>
<p>Both shaders are from the Qt side a string bound to the <em>vertexShader</em> and <em>fragmentShader</em> property. Every shader code has to have a <em>main() { … }</em> function, which is executed by the GPU. Variable starting with <em>qt_</em> are provided by default by Qt already.</p>
<p>Here a short rundown on the variables:</p>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>uniform</td>
<td>value does not change during processing</td>
</tr>
<tr class="row-even"><td>attribute</td>
<td>linkage to external data</td>
</tr>
<tr class="row-odd"><td>varying</td>
<td>shared value between shaders</td>
</tr>
<tr class="row-even"><td>highp</td>
<td>high precision value</td>
</tr>
<tr class="row-odd"><td>lowp</td>
<td>low precision value</td>
</tr>
<tr class="row-even"><td>mat4</td>
<td>4x4 float matrix</td>
</tr>
<tr class="row-odd"><td>vec2</td>
<td>2=dim float vector</td>
</tr>
<tr class="row-even"><td>sampler2D</td>
<td>2D texture</td>
</tr>
<tr class="row-odd"><td>float</td>
<td>floating scalar</td>
</tr>
</tbody>
</table>
<p>A better reference is the <a class="reference external" href="http://www.khronos.org/opengles/sdk/docs/reference_cards/OpenGL-ES-2_0-Reference-card.pdf">OpenGL ES 2.0 API Quick Reference Card</a></p>
<p>Now we might be better able to understand what the variable is:</p>
<ul class="simple">
<li>qt_Matrix: model-view-projection matrix</li>
<li>qt_Vertex: current vertex position</li>
<li>qt_MultiTexCoord0: texture coordinate</li>
<li>qt_TexCoord0: shared texture coordinate</li>
</ul>
<p>So we have available the projection matrix, the current vertex and the texture coordinate. The texture coordinate relates to the texture given as the source. In the <em>main()</em> function we store the texture coordinate for later use in the fragment shader. Every vertex shader needs to assign the <em>gl_Position</em> this is done using here by multiplying the project matrix with the vertex, our point in 3D.</p>
<p>The fragment shader receives our texture coordinate from the vertex shader and also the texture from our QML source property. It shall be noted how easy it is to pass a variable between the shader code and QML. Beautiful. Additional we have the opacity of the shader effect available as <em>qt_Opacity</em>. Every fragment shader needs to assign the <em>gl_FragColor</em> variable, this is done in the default shader code by picking the pixel from the source texture and multiplying it with the opacity.</p>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="nx">fragmentShader</span><span class="o">:</span> <span class="s2">&quot;</span>
<span class="s2">    varying highp vec2 qt_TexCoord0;</span>
<span class="s2">    uniform sampler2D source;</span>
<span class="s2">    uniform lowp float qt_Opacity;</span>
<span class="s2">    void main() {</span>
<span class="s2">        gl_FragColor = texture2D(source, qt_TexCoord0) * qt_Opacity;</span>
<span class="s2">    }&quot;</span>
</pre></div>
</div>
<p>During the next examples, we will be playing around with some simple shader mechanics. First, we concentrate on the fragment shader and then we will come back to the vertex shader.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In the example above, the shader code is written inline in a string inside the QML code. This is supported for OpenGL, but for other platforms a pre-compiled bytecode version of the shader is expected. To import such a shader, simply replace the shader code with a filename refering the the pre-compiled bytecode.</p>
</div>
</div>
<div class="section" id="fragment-shaders">
<h2>10.3. Fragment Shaders<a class="headerlink" href="#fragment-shaders" title="Permalink to this headline">¶</a></h2>
<p><div class="btn-group" role="group"><a class="btn btn-link btn-xs" href="https://github.com/qmlbook/qmlbook//new?labels=ch09&body=back-link%3A+ch10-shaders%2Fshaders.html%23fragment-shaders"><i class="glyphicon glyphicon-plus"></i> Issue</a><a class="btn btn-link btn-xs" href="https://github.com/qmlbook/qmlbook/?labels=ch09&page=1&state=open"><i class="glyphicon glyphicon-search"></i> Issues</a></div></p><p>The fragment shader is called for every pixel to be rendered. We will develop a small red lens, which will increase the red color channel value of the image.</p>
<p class="rubric">Setting up the scene</p>
<p>First, we set up our scene, with a grid centered in the field and our source image be displayed.</p>
<div class="highlight-qml notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nx">QtQuick</span> <span class="mf">2.5</span>

<span class="nx">Rectangle</span> <span class="p">{</span>
    <span class="k">width:</span> <span class="mi">480</span><span class="p">;</span> <span class="k">height:</span> <span class="mi">240</span>
    <span class="k">color:</span> <span class="s1">&#39;#1e1e1e&#39;</span>

    <span class="nx">Grid</span> <span class="p">{</span>
        <span class="k">anchors.centerIn:</span> <span class="nx">parent</span>
        <span class="k">spacing:</span> <span class="mi">20</span>
        <span class="k">rows:</span> <span class="mi">2</span><span class="p">;</span> <span class="k">columns:</span> <span class="mi">4</span>
        <span class="nx">Image</span> <span class="p">{</span>
            <span class="kd">id: sourceImage</span>
            <span class="k">width:</span> <span class="mi">80</span><span class="p">;</span> <span class="k">height:</span> <span class="nx">width</span>
            <span class="k">source:</span> <span class="s1">&#39;assets/tulips.jpg&#39;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="figure">
<img alt="../_images/redlense1.png" src="../_images/redlense1.png" />
</div>
<p class="rubric">A red shader</p>
<p>Next, we will add a shader, which displays a red rectangle by providing for each fragment a red color value.</p>
<div class="highlight-qml notranslate"><div class="highlight"><pre><span></span>            <span class="k">fragmentShader:</span> <span class="s2">&quot;</span>
<span class="s2">                uniform lowp float qt_Opacity;</span>
<span class="s2">                void main() {</span>
<span class="s2">                    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0) * qt_Opacity;</span>
<span class="s2">                }&quot;</span>
</pre></div>
</div>
<p>In the fragment shader we simply assign a <em>vec4(1.0, 0.0, 0.0, 1.0)</em> which represents a red color with full opacity (alpha=1.0) to the <em>gl_FragColor</em> for each fragment.</p>
<div class="figure">
<img alt="../_images/redlense2.png" src="../_images/redlense2.png" />
</div>
<p class="rubric">A red shader with texture</p>
<p>Now we want to apply the red color to each texture pixel. For this, we need the texture back in the vertex shader. As we don’t do anything else in the vertex shader the default vertex shader is enough for us.</p>
<div class="highlight-qml notranslate"><div class="highlight"><pre><span></span>        <span class="nx">ShaderEffect</span> <span class="p">{</span>
            <span class="kd">id: effect2</span>
            <span class="k">width:</span> <span class="mi">80</span><span class="p">;</span> <span class="k">height:</span> <span class="nx">width</span>
            <span class="nx">property</span> <span class="nx">variant</span> <span class="k">source:</span> <span class="nx">sourceImage</span>
            <span class="k">visible:</span> <span class="nx">root</span><span class="p">.</span><span class="nx">step</span><span class="o">&gt;</span><span class="mi">1</span>
            <span class="k">fragmentShader:</span> <span class="s2">&quot;</span>
<span class="s2">                varying highp vec2 qt_TexCoord0;</span>
<span class="s2">                uniform sampler2D source;</span>
<span class="s2">                uniform lowp float qt_Opacity;</span>
<span class="s2">                void main() {</span>
<span class="s2">                    gl_FragColor = texture2D(source, qt_TexCoord0) * vec4(1.0, 0.0, 0.0, 1.0) * qt_Opacity;</span>
<span class="s2">                }&quot;</span>
        <span class="p">}</span>
</pre></div>
</div>
<p>The full shader contains now back our image source as variant property and we have left out the vertex shader, which if not specified is the default vertex shader.</p>
<p>In the fragment shader, we pick the texture fragment <em>texture2D(source, qt_TexCoord0)</em> and apply the red color to it.</p>
<div class="figure">
<img alt="../_images/redlense3.png" src="../_images/redlense3.png" />
</div>
<p class="rubric">The red channel property</p>
<p>It’s not really nice to hard code the red channel value, so we would like to control the value from the QML side. For this we add a <em>redChannel</em> property to our shader effect and also declare a <em>uniform lowp float redChannel</em> inside our fragment shader. That’s all to make a value from the shader code available to the QML side. Very simple.</p>
<div class="highlight-qml notranslate"><div class="highlight"><pre><span></span>        <span class="nx">ShaderEffect</span> <span class="p">{</span>
            <span class="kd">id: effect3</span>
            <span class="k">width:</span> <span class="mi">80</span><span class="p">;</span> <span class="k">height:</span> <span class="nx">width</span>
            <span class="nx">property</span> <span class="nx">variant</span> <span class="k">source:</span> <span class="nx">sourceImage</span>
            <span class="nx">property</span> <span class="nx">real</span> <span class="k">redChannel:</span> <span class="mf">0.3</span>
            <span class="k">visible:</span> <span class="nx">root</span><span class="p">.</span><span class="nx">step</span><span class="o">&gt;</span><span class="mi">2</span>
            <span class="k">fragmentShader:</span> <span class="s2">&quot;</span>
<span class="s2">                varying highp vec2 qt_TexCoord0;</span>
<span class="s2">                uniform sampler2D source;</span>
<span class="s2">                uniform lowp float qt_Opacity;</span>
<span class="s2">                uniform lowp float redChannel;</span>
<span class="s2">                void main() {</span>
<span class="s2">                    gl_FragColor = texture2D(source, qt_TexCoord0) * vec4(redChannel, 1.0, 1.0, 1.0) * qt_Opacity;</span>
<span class="s2">                }&quot;</span>
        <span class="p">}</span>
</pre></div>
</div>
<p>To make the lens really a lens, we change the <em>vec4</em> color to be <em>vec4(redChannel, 1.0, 1.0, 1.0)</em> so that the other colors are multiplied by 1.0 and only the red portion is multiplied by our <em>redChannel</em> variable.</p>
<div class="figure">
<img alt="../_images/redlense4.png" src="../_images/redlense4.png" />
</div>
<p class="rubric">The red channel animated</p>
<p>As the <em>redChannel</em> property is just a normal property it can also be animated as all properties in QML. So we can use QML properties to animate values on the GPU to influence our shaders. How cool is that!</p>
<div class="highlight-qml notranslate"><div class="highlight"><pre><span></span>        <span class="nx">ShaderEffect</span> <span class="p">{</span>
            <span class="kd">id: effect4</span>
            <span class="k">width:</span> <span class="mi">80</span><span class="p">;</span> <span class="k">height:</span> <span class="nx">width</span>
            <span class="nx">property</span> <span class="nx">variant</span> <span class="k">source:</span> <span class="nx">sourceImage</span>
            <span class="nx">property</span> <span class="nx">real</span> <span class="k">redChannel:</span> <span class="mf">0.3</span>
            <span class="k">visible:</span> <span class="nx">root</span><span class="p">.</span><span class="nx">step</span><span class="o">&gt;</span><span class="mi">3</span>
            <span class="nx">NumberAnimation</span> <span class="nx">on</span> <span class="nx">redChannel</span> <span class="p">{</span>
                <span class="k">from:</span> <span class="mf">0.0</span><span class="p">;</span> <span class="k">to:</span> <span class="mf">1.0</span><span class="p">;</span> <span class="k">loops:</span> <span class="nx">Animation</span><span class="p">.</span><span class="nx">Infinite</span><span class="p">;</span> <span class="k">duration:</span> <span class="mi">4000</span>
            <span class="p">}</span>

            <span class="k">fragmentShader:</span> <span class="s2">&quot;</span>
<span class="s2">                varying highp vec2 qt_TexCoord0;</span>
<span class="s2">                uniform sampler2D source;</span>
<span class="s2">                uniform lowp float qt_Opacity;</span>
<span class="s2">                uniform lowp float redChannel;</span>
<span class="s2">                void main() {</span>
<span class="s2">                    gl_FragColor = texture2D(source, qt_TexCoord0) * vec4(redChannel, 1.0, 1.0, 1.0) * qt_Opacity;</span>
<span class="s2">                }&quot;</span>
        <span class="p">}</span>
</pre></div>
</div>
<p>Here the final result.</p>
<div class="figure">
<img alt="../_images/redlense5.png" src="../_images/redlense5.png" />
</div>
<p>The shader effect on the 2nd row is animated from 0.0 to 1.0 with a duration of 4 seconds. So the image goes from no red information (0.0 red) over to a normal image (1.0 red).</p>
</div>
<div class="section" id="wave-effect">
<h2>10.4. Wave Effect<a class="headerlink" href="#wave-effect" title="Permalink to this headline">¶</a></h2>
<p><div class="btn-group" role="group"><a class="btn btn-link btn-xs" href="https://github.com/qmlbook/qmlbook//new?labels=ch09&body=back-link%3A+ch10-shaders%2Fshaders.html%23wave-effect"><i class="glyphicon glyphicon-plus"></i> Issue</a><a class="btn btn-link btn-xs" href="https://github.com/qmlbook/qmlbook/?labels=ch09&page=1&state=open"><i class="glyphicon glyphicon-search"></i> Issues</a></div></p><p>In this more complex example, we will create a wave effect with the fragment shader. The waveform is based on the sinus curve and it influences the texture coordinates used for the color.</p>
<div class="highlight-qml notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nx">QtQuick</span> <span class="mf">2.5</span>

<span class="nx">Rectangle</span> <span class="p">{</span>
    <span class="k">width:</span> <span class="mi">480</span><span class="p">;</span> <span class="k">height:</span> <span class="mi">240</span>
    <span class="k">color:</span> <span class="s1">&#39;#1e1e1e&#39;</span>

    <span class="nx">Row</span> <span class="p">{</span>
        <span class="k">anchors.centerIn:</span> <span class="nx">parent</span>
        <span class="k">spacing:</span> <span class="mi">20</span>
        <span class="nx">Image</span> <span class="p">{</span>
            <span class="kd">id: sourceImage</span>
            <span class="k">width:</span> <span class="mi">160</span><span class="p">;</span> <span class="k">height:</span> <span class="nx">width</span>
            <span class="k">source:</span> <span class="s2">&quot;assets/coastline.jpg&quot;</span>
        <span class="p">}</span>
        <span class="nx">ShaderEffect</span> <span class="p">{</span>
            <span class="k">width:</span> <span class="mi">160</span><span class="p">;</span> <span class="k">height:</span> <span class="nx">width</span>
            <span class="nx">property</span> <span class="nx">variant</span> <span class="k">source:</span> <span class="nx">sourceImage</span>
            <span class="nx">property</span> <span class="nx">real</span> <span class="k">frequency:</span> <span class="mi">8</span>
            <span class="nx">property</span> <span class="nx">real</span> <span class="k">amplitude:</span> <span class="mf">0.1</span>
            <span class="nx">property</span> <span class="nx">real</span> <span class="k">time:</span> <span class="mf">0.0</span>
            <span class="nx">NumberAnimation</span> <span class="nx">on</span> <span class="nx">time</span> <span class="p">{</span>
                <span class="k">from:</span> <span class="mi">0</span><span class="p">;</span> <span class="k">to:</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span><span class="o">*</span><span class="mi">2</span><span class="p">;</span> <span class="k">duration:</span> <span class="mi">1000</span><span class="p">;</span> <span class="k">loops:</span> <span class="nx">Animation</span><span class="p">.</span><span class="nx">Infinite</span>
            <span class="p">}</span>

            <span class="k">fragmentShader:</span> <span class="s2">&quot;</span>
<span class="s2">                varying highp vec2 qt_TexCoord0;</span>
<span class="s2">                uniform sampler2D source;</span>
<span class="s2">                uniform lowp float qt_Opacity;</span>
<span class="s2">                uniform highp float frequency;</span>
<span class="s2">                uniform highp float amplitude;</span>
<span class="s2">                uniform highp float time;</span>
<span class="s2">                void main() {</span>
<span class="s2">                    highp vec2 pulse = sin(time - frequency * qt_TexCoord0);</span>
<span class="s2">                    highp vec2 coord = qt_TexCoord0 + amplitude * vec2(pulse.x, -pulse.x);</span>
<span class="s2">                    gl_FragColor = texture2D(source, coord) * qt_Opacity;</span>
<span class="s2">                }&quot;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The wave calculation is based on a pulse and the texture coordinate manipulation. The pulse equation gives us a sine wave depending on the current time and the used texture coordinate:</p>
<div class="highlight-qml notranslate"><div class="highlight"><pre><span></span><span class="nx">highp</span> <span class="nx">vec2</span> <span class="nx">pulse</span> <span class="o">=</span> <span class="nx">sin</span><span class="p">(</span><span class="nx">time</span> <span class="o">-</span> <span class="nx">frequency</span> <span class="o">*</span> <span class="nx">qt_TexCoord0</span><span class="p">);</span>
</pre></div>
</div>
<p>Without the time factor, we would just have a distortion but not a traveling distortion like waves are.</p>
<p>For the color we use the color at a different texture coordinate:</p>
<div class="highlight-qml notranslate"><div class="highlight"><pre><span></span><span class="nx">highp</span> <span class="nx">vec2</span> <span class="nx">coord</span> <span class="o">=</span> <span class="nx">qt_TexCoord0</span> <span class="o">+</span> <span class="nx">amplitude</span> <span class="o">*</span> <span class="nx">vec2</span><span class="p">(</span><span class="nx">pulse</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="o">-</span><span class="nx">pulse</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span>
</pre></div>
</div>
<p>The texture coordinate is influenced by our pulse x-value. The result of this is a moving wave.</p>
<div class="figure">
<img alt="../_images/wave.png" src="../_images/wave.png" />
</div>
<p>Also if we haven’t moved pixels in this fragment shader the effect would look at first like a job for a vertex shader.</p>
</div>
<div class="section" id="vertex-shader">
<h2>10.5. Vertex Shader<a class="headerlink" href="#vertex-shader" title="Permalink to this headline">¶</a></h2>
<p><div class="btn-group" role="group"><a class="btn btn-link btn-xs" href="https://github.com/qmlbook/qmlbook//new?labels=ch09&body=back-link%3A+ch10-shaders%2Fshaders.html%23vertex-shader"><i class="glyphicon glyphicon-plus"></i> Issue</a><a class="btn btn-link btn-xs" href="https://github.com/qmlbook/qmlbook/?labels=ch09&page=1&state=open"><i class="glyphicon glyphicon-search"></i> Issues</a></div></p><p>The vertex shader can be used to manipulate the vertexes provided by the shader effect. In normal cases, the shader effect has 4 vertexes (top-left, top-right, bottom-left and bottom-right). Each vertex reported is from type vec4. To visualize the vertex shader we will program a genie effect. This effect is often used to let a rectangular window area vanish into one point.</p>
<div class="figure">
<img alt="../_images/genieeffect.png" src="../_images/genieeffect.png" />
</div>
<p class="rubric">Setting up the scene</p>
<p>First, we will set up our scene again.</p>
<div class="highlight-qml notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nx">QtQuick</span> <span class="mf">2.5</span>

<span class="nx">Rectangle</span> <span class="p">{</span>
    <span class="k">width:</span> <span class="mi">480</span><span class="p">;</span> <span class="k">height:</span> <span class="mi">240</span>
    <span class="k">color:</span> <span class="s1">&#39;#1e1e1e&#39;</span>

    <span class="nx">Image</span> <span class="p">{</span>
        <span class="kd">id: sourceImage</span>
        <span class="k">width:</span> <span class="mi">160</span><span class="p">;</span> <span class="k">height:</span> <span class="nx">width</span>
        <span class="k">source:</span> <span class="s2">&quot;assets/lighthouse.jpg&quot;</span>
        <span class="k">visible:</span> <span class="kc">false</span>
    <span class="p">}</span>
    <span class="nx">Rectangle</span> <span class="p">{</span>
        <span class="k">width:</span> <span class="mi">160</span><span class="p">;</span> <span class="k">height:</span> <span class="nx">width</span>
        <span class="k">anchors.centerIn:</span> <span class="nx">parent</span>
        <span class="k">color:</span> <span class="s1">&#39;#333333&#39;</span>
    <span class="p">}</span>
    <span class="nx">ShaderEffect</span> <span class="p">{</span>
        <span class="kd">id: genieEffect</span>
        <span class="k">width:</span> <span class="mi">160</span><span class="p">;</span> <span class="k">height:</span> <span class="nx">width</span>
        <span class="k">anchors.centerIn:</span> <span class="nx">parent</span>
        <span class="nx">property</span> <span class="nx">variant</span> <span class="k">source:</span> <span class="nx">sourceImage</span>
        <span class="nx">property</span> <span class="nx">bool</span> <span class="k">minimized:</span> <span class="kc">false</span>
        <span class="nx">MouseArea</span> <span class="p">{</span>
            <span class="k">anchors.fill:</span> <span class="nx">parent</span>
            <span class="k">onClicked:</span> <span class="nx">genieEffect</span><span class="p">.</span><span class="nx">minimized</span> <span class="o">=</span> <span class="o">!</span><span class="nx">genieEffect</span><span class="p">.</span><span class="nx">minimized</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This provides a scene with a dark background and a shader effect using an image as the source texture. The original image is not visible on the image produced by our genie effect. Additional we added a dark rectangle on the same geometry as the shader effect so we can better detect where we need to click to revert the effect.</p>
<div class="figure">
<img alt="../_images/geniescene.png" src="../_images/geniescene.png" />
</div>
<p>The effect is triggered by clicking on the image, this is defined by the mouse area covering the effect. In the <em>onClicked</em> handler we toggle the custom boolean property <em>minimized</em>. We will use this property later to toggle the effect.</p>
<p class="rubric">Minimize and normalize</p>
<p>After we have set up the scene, we define a property of type real called <em>minimize</em>, the property will contain the current value of our minimization. The value will vary from 0.0 to 1.0 and is controlled by a sequential animation.</p>
<div class="highlight-qml notranslate"><div class="highlight"><pre><span></span>        <span class="nx">property</span> <span class="nx">real</span> <span class="k">minimize:</span> <span class="mf">0.0</span>

        <span class="nx">SequentialAnimation</span> <span class="nx">on</span> <span class="nx">minimize</span> <span class="p">{</span>
            <span class="kd">id: animMinimize</span>
            <span class="k">running:</span> <span class="nx">genieEffect</span><span class="p">.</span><span class="nx">minimized</span>
            <span class="nx">PauseAnimation</span> <span class="p">{</span> <span class="k">duration:</span> <span class="mi">300</span> <span class="p">}</span>
            <span class="nx">NumberAnimation</span> <span class="p">{</span> <span class="k">to:</span> <span class="mi">1</span><span class="p">;</span> <span class="k">duration:</span> <span class="mi">700</span><span class="p">;</span> <span class="k">easing.type:</span> <span class="nx">Easing</span><span class="p">.</span><span class="nx">InOutSine</span> <span class="p">}</span>
            <span class="nx">PauseAnimation</span> <span class="p">{</span> <span class="k">duration:</span> <span class="mi">1000</span> <span class="p">}</span>
        <span class="p">}</span>

        <span class="nx">SequentialAnimation</span> <span class="nx">on</span> <span class="nx">minimize</span> <span class="p">{</span>
            <span class="kd">id: animNormalize</span>
            <span class="k">running:</span> <span class="o">!</span><span class="nx">genieEffect</span><span class="p">.</span><span class="nx">minimized</span>
            <span class="nx">NumberAnimation</span> <span class="p">{</span> <span class="k">to:</span> <span class="mi">0</span><span class="p">;</span> <span class="k">duration:</span> <span class="mi">700</span><span class="p">;</span> <span class="k">easing.type:</span> <span class="nx">Easing</span><span class="p">.</span><span class="nx">InOutSine</span> <span class="p">}</span>
            <span class="nx">PauseAnimation</span> <span class="p">{</span> <span class="k">duration:</span> <span class="mi">1300</span> <span class="p">}</span>
        <span class="p">}</span>
</pre></div>
</div>
<p>The animation is triggered by the toggling of the <em>minimized</em> property. Now that we have set up all our surroundings we finally can look at our vertex shader.</p>
<div class="highlight-qml notranslate"><div class="highlight"><pre><span></span>        <span class="k">vertexShader:</span> <span class="s2">&quot;</span>
<span class="s2">            uniform highp mat4 qt_Matrix;</span>
<span class="s2">            attribute highp vec4 qt_Vertex;</span>
<span class="s2">            attribute highp vec2 qt_MultiTexCoord0;</span>
<span class="s2">            varying highp vec2 qt_TexCoord0;</span>
<span class="s2">            uniform highp float minimize;</span>
<span class="s2">            uniform highp float width;</span>
<span class="s2">            uniform highp float height;</span>
<span class="s2">            void main() {</span>
<span class="s2">                qt_TexCoord0 = qt_MultiTexCoord0;</span>
<span class="s2">                highp vec4 pos = qt_Vertex;</span>
<span class="s2">                pos.y = mix(qt_Vertex.y, height, minimize);</span>
<span class="s2">                pos.x = mix(qt_Vertex.x, width, minimize);</span>
<span class="s2">                gl_Position = qt_Matrix * pos;</span>
<span class="s2">            }&quot;</span>
</pre></div>
</div>
<p>The vertex shader is called for each vertex so four times, in our case. The default qt defined parameters are provided, like <em>qt_Matrix</em>, <em>qt_Vertex</em>, <em>qt_MultiTexCoord0</em>, <em>qt_TexCoord0</em>. We have discussed the variable already earlier. Additional we link the <em>minimize</em>, <em>width</em> and <em>height</em> variables from our shader effect into our vertex shader code. In the main function, we store the current texture coordinate in our <em>qt_TexCoord0</em> to make it available to the fragment shader. Now we copy the current position and modify the x and y position of the vertex:</p>
<div class="highlight-qml notranslate"><div class="highlight"><pre><span></span><span class="nx">highp</span> <span class="nx">vec4</span> <span class="nx">pos</span> <span class="o">=</span> <span class="nx">qt_Vertex</span><span class="p">;</span>
<span class="nx">pos</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">mix</span><span class="p">(</span><span class="nx">qt_Vertex</span><span class="p">.</span><span class="nx">y</span><span class="p">,</span> <span class="nx">height</span><span class="p">,</span> <span class="nx">minimize</span><span class="p">);</span>
<span class="nx">pos</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">mix</span><span class="p">(</span><span class="nx">qt_Vertex</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="nx">width</span><span class="p">,</span> <span class="nx">minimize</span><span class="p">);</span>
</pre></div>
</div>
<p>The <em>mix(…)</em> function provides a linear interpolation between the first 2 parameters on the point (0.0-1.0) provided by the 3rd parameter. So in our case, we interpolate for y between the current y position and the hight based on the current minimized value, similar for x. Bear in mind the minimized value is animated by our sequential animation and travels from 0.0 to 1.0 (or vice versa).</p>
<div class="figure">
<img alt="../_images/genieminimize.png" src="../_images/genieminimize.png" />
</div>
<p>The resulting effect is not really the genie effect but is already a great step towards it.</p>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">better explanation, maybe draw the 4 vertexes and their interpolation</p>
</div>
<p class="rubric">Primitive Bending</p>
<p>So minimized the x and y components of our vertexes. Now we would like to slightly modify the x manipulation and make it depending on the current y value. The needed changes are pretty small. The y-position is calculated as before. The interpolation of the x-position depends now on the vertexes y-position:</p>
<div class="highlight-qml notranslate"><div class="highlight"><pre><span></span><span class="nx">highp</span> <span class="kr">float</span> <span class="nx">t</span> <span class="o">=</span> <span class="nx">pos</span><span class="p">.</span><span class="nx">y</span> <span class="o">/</span> <span class="nx">height</span><span class="p">;</span>
<span class="nx">pos</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">mix</span><span class="p">(</span><span class="nx">qt_Vertex</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="nx">width</span><span class="p">,</span> <span class="nx">t</span> <span class="o">*</span> <span class="nx">minimize</span><span class="p">);</span>
</pre></div>
</div>
<p>This results in an x-position tending towards the width when the y-position is larger. In other words, the upper 2 vertexes are not affected at all as they have a y-position of 0 and the lower two vertexes x-positions both bend towards the width, so they bend towards the same x-position.</p>
<div class="figure">
<img alt="../_images/geniebending.png" src="../_images/geniebending.png" />
</div>
<div class="highlight-qml notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nx">QtQuick</span> <span class="mf">2.5</span>

<span class="nx">Rectangle</span> <span class="p">{</span>
    <span class="k">width:</span> <span class="mi">480</span><span class="p">;</span> <span class="k">height:</span> <span class="mi">240</span>
    <span class="k">color:</span> <span class="s2">&quot;#1e1e1e&quot;</span>

    <span class="nx">Image</span> <span class="p">{</span>
        <span class="kd">id: sourceImage</span>
        <span class="k">width:</span> <span class="mi">160</span><span class="p">;</span> <span class="k">height:</span> <span class="nx">width</span>
        <span class="k">source:</span> <span class="s2">&quot;assets/lighthouse.jpg&quot;</span>
        <span class="k">visible:</span> <span class="kc">false</span>
    <span class="p">}</span>
    <span class="nx">Rectangle</span> <span class="p">{</span>
        <span class="k">width:</span> <span class="mi">160</span><span class="p">;</span> <span class="k">height:</span> <span class="nx">width</span>
        <span class="k">anchors.centerIn:</span> <span class="nx">parent</span>
        <span class="k">color:</span> <span class="s2">&quot;#333333&quot;</span>
    <span class="p">}</span>
    <span class="nx">ShaderEffect</span> <span class="p">{</span>
        <span class="kd">id: genieEffect</span>
        <span class="k">width:</span> <span class="mi">160</span><span class="p">;</span> <span class="k">height:</span> <span class="nx">width</span>
        <span class="k">anchors.centerIn:</span> <span class="nx">parent</span>
        <span class="nx">property</span> <span class="nx">variant</span> <span class="k">source:</span> <span class="nx">sourceImage</span>
        <span class="nx">property</span> <span class="nx">real</span> <span class="k">minimize:</span> <span class="mf">0.0</span>
        <span class="nx">property</span> <span class="nx">bool</span> <span class="k">minimized:</span> <span class="kc">false</span>


        <span class="nx">SequentialAnimation</span> <span class="nx">on</span> <span class="nx">minimize</span> <span class="p">{</span>
            <span class="kd">id: animMinimize</span>
            <span class="k">running:</span> <span class="nx">genieEffect</span><span class="p">.</span><span class="nx">minimized</span>
            <span class="nx">PauseAnimation</span> <span class="p">{</span> <span class="k">duration:</span> <span class="mi">300</span> <span class="p">}</span>
            <span class="nx">NumberAnimation</span> <span class="p">{</span> <span class="k">to:</span> <span class="mi">1</span><span class="p">;</span> <span class="k">duration:</span> <span class="mi">700</span><span class="p">;</span> <span class="k">easing.type:</span> <span class="nx">Easing</span><span class="p">.</span><span class="nx">InOutSine</span> <span class="p">}</span>
            <span class="nx">PauseAnimation</span> <span class="p">{</span> <span class="k">duration:</span> <span class="mi">1000</span> <span class="p">}</span>
        <span class="p">}</span>

        <span class="nx">SequentialAnimation</span> <span class="nx">on</span> <span class="nx">minimize</span> <span class="p">{</span>
            <span class="kd">id: animNormalize</span>
            <span class="k">running:</span> <span class="o">!</span><span class="nx">genieEffect</span><span class="p">.</span><span class="nx">minimized</span>
            <span class="nx">NumberAnimation</span> <span class="p">{</span> <span class="k">to:</span> <span class="mi">0</span><span class="p">;</span> <span class="k">duration:</span> <span class="mi">700</span><span class="p">;</span> <span class="k">easing.type:</span> <span class="nx">Easing</span><span class="p">.</span><span class="nx">InOutSine</span> <span class="p">}</span>
            <span class="nx">PauseAnimation</span> <span class="p">{</span> <span class="k">duration:</span> <span class="mi">1300</span> <span class="p">}</span>
        <span class="p">}</span>


        <span class="k">vertexShader:</span> <span class="s2">&quot;</span>
<span class="s2">            uniform highp mat4 qt_Matrix;</span>
<span class="s2">            uniform highp float minimize;</span>
<span class="s2">            uniform highp float height;</span>
<span class="s2">            uniform highp float width;</span>
<span class="s2">            attribute highp vec4 qt_Vertex;</span>
<span class="s2">            attribute highp vec2 qt_MultiTexCoord0;</span>
<span class="s2">            varying highp vec2 qt_TexCoord0;</span>
<span class="s2">            void main() {</span>
<span class="s2">                qt_TexCoord0 = qt_MultiTexCoord0;</span>
<span class="s2">                highp vec4 pos = qt_Vertex;</span>
<span class="s2">                pos.y = mix(qt_Vertex.y, height, minimize);</span>
<span class="s2">                highp float t = pos.y / height;</span>
<span class="s2">                pos.x = mix(qt_Vertex.x, width, t * minimize);</span>
<span class="s2">                gl_Position = qt_Matrix * pos;</span>
<span class="s2">            }&quot;</span>
        <span class="nx">MouseArea</span> <span class="p">{</span>
            <span class="k">anchors.fill:</span> <span class="nx">parent</span>
            <span class="k">onClicked:</span> <span class="nx">parent</span><span class="p">.</span><span class="nx">minimized</span> <span class="o">=</span> <span class="o">!</span><span class="nx">parent</span><span class="p">.</span><span class="nx">minimized</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">Better Bending</p>
<p>As the bending is not really satisfying currently we will add several parts to improve the situation.
First, we enhance our animation to support an own bending property. This is necessary as the bending should happen immediately and the y-minimization should be delayed shortly. Both animations have in the sum the same duration (300+700+1000 and 700+1300).</p>
<div class="highlight-qml notranslate"><div class="highlight"><pre><span></span>        <span class="nx">property</span> <span class="nx">real</span> <span class="k">bend:</span> <span class="mf">0.0</span>
        <span class="nx">property</span> <span class="nx">bool</span> <span class="k">minimized:</span> <span class="kc">false</span>


        <span class="c1">// change to parallel animation</span>
        <span class="nx">ParallelAnimation</span> <span class="p">{</span>
            <span class="kd">id: animMinimize</span>
            <span class="k">running:</span> <span class="nx">genieEffect</span><span class="p">.</span><span class="nx">minimized</span>
            <span class="nx">SequentialAnimation</span> <span class="p">{</span>
                <span class="nx">PauseAnimation</span> <span class="p">{</span> <span class="k">duration:</span> <span class="mi">300</span> <span class="p">}</span>
                <span class="nx">NumberAnimation</span> <span class="p">{</span>
                    <span class="k">target:</span> <span class="nx">genieEffect</span><span class="p">;</span> <span class="k">property:</span> <span class="s1">&#39;minimize&#39;</span><span class="p">;</span>
                    <span class="k">to:</span> <span class="mi">1</span><span class="p">;</span> <span class="k">duration:</span> <span class="mi">700</span><span class="p">;</span>
                    <span class="k">easing.type:</span> <span class="nx">Easing</span><span class="p">.</span><span class="nx">InOutSine</span>
                <span class="p">}</span>
                <span class="nx">PauseAnimation</span> <span class="p">{</span> <span class="k">duration:</span> <span class="mi">1000</span> <span class="p">}</span>
            <span class="p">}</span>
            <span class="c1">// adding bend animation</span>
            <span class="nx">SequentialAnimation</span> <span class="p">{</span>
                <span class="nx">NumberAnimation</span> <span class="p">{</span>
                    <span class="k">target:</span> <span class="nx">genieEffect</span><span class="p">;</span> <span class="k">property:</span> <span class="s1">&#39;bend&#39;</span>
                    <span class="k">to:</span> <span class="mi">1</span><span class="p">;</span> <span class="k">duration:</span> <span class="mi">700</span><span class="p">;</span>
                    <span class="k">easing.type:</span> <span class="nx">Easing</span><span class="p">.</span><span class="nx">InOutSine</span> <span class="p">}</span>
                <span class="nx">PauseAnimation</span> <span class="p">{</span> <span class="k">duration:</span> <span class="mi">1300</span> <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
</pre></div>
</div>
<p>Additional to make the bending a smooth curve the y-effect on the x-position is not modified by a curved function from 0..1 and the <code class="docutils literal notranslate"><span class="pre">pos.x</span></code> depends now on the new bend property animation:</p>
<div class="highlight-qml notranslate"><div class="highlight"><pre><span></span><span class="nx">highp</span> <span class="kr">float</span> <span class="nx">t</span> <span class="o">=</span> <span class="nx">pos</span><span class="p">.</span><span class="nx">y</span> <span class="o">/</span> <span class="nx">height</span><span class="p">;</span>
<span class="nx">t</span> <span class="o">=</span> <span class="p">(</span><span class="mf">3.0</span> <span class="o">-</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="nx">t</span><span class="p">)</span> <span class="o">*</span> <span class="nx">t</span> <span class="o">*</span> <span class="nx">t</span><span class="p">;</span>
<span class="nx">pos</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">mix</span><span class="p">(</span><span class="nx">qt_Vertex</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="nx">width</span><span class="p">,</span> <span class="nx">t</span> <span class="o">*</span> <span class="nx">bend</span><span class="p">);</span>
</pre></div>
</div>
<p>The curve starts smooth at the 0.0 value, grows then and stops smoothly towards the 1.0 value. Here is a plot of the function in the specified range. For us, only the range from 0..1 is from interest.</p>
<div class="figure">
<img alt="../_images/curve.png" src="../_images/curve.png" />
</div>
<p>The most visual change is by increasing our amount of vertex points. The vertex points used can be increased by using a mesh:</p>
<div class="highlight-qml notranslate"><div class="highlight"><pre><span></span><span class="k">mesh:</span> <span class="nx">GridMesh</span> <span class="p">{</span> <span class="k">resolution:</span> <span class="nx">Qt</span><span class="p">.</span><span class="nx">size</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
<p>The shader effect now has an equality distributed grid of 16x16 vertexes instead of the 2x2 vertexes used before. This makes the interpolation between the vertexes look much smoother.</p>
<div class="figure">
<img alt="../_images/geniesmoothbending.png" src="../_images/geniesmoothbending.png" />
</div>
<p>You can see also the influence of the curve being used, as the bending smoothes at the end nicely. This is where the bending has the strongest effect.</p>
<p class="rubric">Choosing Sides</p>
<p>As a final enhancement, we want to be able to switch sides. The side is towards which point the genie effect vanishes. Till now it vanishes always towards the width. By adding a <em>side</em> property we are able to modify the point between 0 and width.</p>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="nx">ShaderEffect</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="nx">property</span> <span class="nx">real</span> <span class="nx">side</span><span class="o">:</span> <span class="mf">0.5</span>

    <span class="nx">vertexShader</span><span class="o">:</span> <span class="s2">&quot;</span>
<span class="s2">        ...</span>
<span class="s2">        uniform highp float side;</span>
<span class="s2">        ...</span>
<span class="s2">        pos.x = mix(qt_Vertex.x, side * width, t * bend);</span>
<span class="s2">    &quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="figure">
<img alt="../_images/geniehalfside.png" src="../_images/geniehalfside.png" />
</div>
<p class="rubric">Packaging</p>
<p>The last thing to-do is packaging our effect nicely. For this, we extract our genie effect code into an own component called <em>GenieEffect</em>. It has the shader effect as the root element. We removed the mouse area as this should not be inside the component as the triggering of the effect can be toggled by the <em>minimized</em> property.</p>
<div class="highlight-qml notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nx">QtQuick</span> <span class="mf">2.5</span>

<span class="nx">ShaderEffect</span> <span class="p">{</span>
    <span class="kd">id: genieEffect</span>
    <span class="k">width:</span> <span class="mi">160</span><span class="p">;</span> <span class="k">height:</span> <span class="nx">width</span>
    <span class="k">anchors.centerIn:</span> <span class="nx">parent</span>
    <span class="nx">property</span> <span class="nx">variant</span> <span class="nx">source</span>
    <span class="k">mesh:</span> <span class="nx">GridMesh</span> <span class="p">{</span> <span class="k">resolution:</span> <span class="nx">Qt</span><span class="p">.</span><span class="nx">size</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="p">}</span>
    <span class="nx">property</span> <span class="nx">real</span> <span class="k">minimize:</span> <span class="mf">0.0</span>
    <span class="nx">property</span> <span class="nx">real</span> <span class="k">bend:</span> <span class="mf">0.0</span>
    <span class="nx">property</span> <span class="nx">bool</span> <span class="k">minimized:</span> <span class="kc">false</span>
    <span class="nx">property</span> <span class="nx">real</span> <span class="k">side:</span> <span class="mf">1.0</span>


    <span class="nx">ParallelAnimation</span> <span class="p">{</span>
        <span class="kd">id: animMinimize</span>
        <span class="k">running:</span> <span class="nx">genieEffect</span><span class="p">.</span><span class="nx">minimized</span>
        <span class="nx">SequentialAnimation</span> <span class="p">{</span>
            <span class="nx">PauseAnimation</span> <span class="p">{</span> <span class="k">duration:</span> <span class="mi">300</span> <span class="p">}</span>
            <span class="nx">NumberAnimation</span> <span class="p">{</span>
                <span class="k">target:</span> <span class="nx">genieEffect</span><span class="p">;</span> <span class="k">property:</span> <span class="s1">&#39;minimize&#39;</span><span class="p">;</span>
                <span class="k">to:</span> <span class="mi">1</span><span class="p">;</span> <span class="k">duration:</span> <span class="mi">700</span><span class="p">;</span>
                <span class="k">easing.type:</span> <span class="nx">Easing</span><span class="p">.</span><span class="nx">InOutSine</span>
            <span class="p">}</span>
            <span class="nx">PauseAnimation</span> <span class="p">{</span> <span class="k">duration:</span> <span class="mi">1000</span> <span class="p">}</span>
        <span class="p">}</span>
        <span class="nx">SequentialAnimation</span> <span class="p">{</span>
            <span class="nx">NumberAnimation</span> <span class="p">{</span>
                <span class="k">target:</span> <span class="nx">genieEffect</span><span class="p">;</span> <span class="k">property:</span> <span class="s1">&#39;bend&#39;</span>
                <span class="k">to:</span> <span class="mi">1</span><span class="p">;</span> <span class="k">duration:</span> <span class="mi">700</span><span class="p">;</span>
                <span class="k">easing.type:</span> <span class="nx">Easing</span><span class="p">.</span><span class="nx">InOutSine</span> <span class="p">}</span>
            <span class="nx">PauseAnimation</span> <span class="p">{</span> <span class="k">duration:</span> <span class="mi">1300</span> <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">ParallelAnimation</span> <span class="p">{</span>
        <span class="kd">id: animNormalize</span>
        <span class="k">running:</span> <span class="o">!</span><span class="nx">genieEffect</span><span class="p">.</span><span class="nx">minimized</span>
        <span class="nx">SequentialAnimation</span> <span class="p">{</span>
            <span class="nx">NumberAnimation</span> <span class="p">{</span>
                <span class="k">target:</span> <span class="nx">genieEffect</span><span class="p">;</span> <span class="k">property:</span> <span class="s1">&#39;minimize&#39;</span><span class="p">;</span>
                <span class="k">to:</span> <span class="mi">0</span><span class="p">;</span> <span class="k">duration:</span> <span class="mi">700</span><span class="p">;</span>
                <span class="k">easing.type:</span> <span class="nx">Easing</span><span class="p">.</span><span class="nx">InOutSine</span>
            <span class="p">}</span>
            <span class="nx">PauseAnimation</span> <span class="p">{</span> <span class="k">duration:</span> <span class="mi">1300</span> <span class="p">}</span>
        <span class="p">}</span>
        <span class="nx">SequentialAnimation</span> <span class="p">{</span>
            <span class="nx">PauseAnimation</span> <span class="p">{</span> <span class="k">duration:</span> <span class="mi">300</span> <span class="p">}</span>
            <span class="nx">NumberAnimation</span> <span class="p">{</span>
                <span class="k">target:</span> <span class="nx">genieEffect</span><span class="p">;</span> <span class="k">property:</span> <span class="s1">&#39;bend&#39;</span>
                <span class="k">to:</span> <span class="mi">0</span><span class="p">;</span> <span class="k">duration:</span> <span class="mi">700</span><span class="p">;</span>
                <span class="k">easing.type:</span> <span class="nx">Easing</span><span class="p">.</span><span class="nx">InOutSine</span> <span class="p">}</span>
            <span class="nx">PauseAnimation</span> <span class="p">{</span> <span class="k">duration:</span> <span class="mi">1000</span> <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">vertexShader:</span> <span class="s2">&quot;</span>
<span class="s2">        uniform highp mat4 qt_Matrix;</span>
<span class="s2">        attribute highp vec4 qt_Vertex;</span>
<span class="s2">        attribute highp vec2 qt_MultiTexCoord0;</span>
<span class="s2">        uniform highp float height;</span>
<span class="s2">        uniform highp float width;</span>
<span class="s2">        uniform highp float minimize;</span>
<span class="s2">        uniform highp float bend;</span>
<span class="s2">        uniform highp float side;</span>
<span class="s2">        varying highp vec2 qt_TexCoord0;</span>
<span class="s2">        void main() {</span>
<span class="s2">            qt_TexCoord0 = qt_MultiTexCoord0;</span>
<span class="s2">            highp vec4 pos = qt_Vertex;</span>
<span class="s2">            pos.y = mix(qt_Vertex.y, height, minimize);</span>
<span class="s2">            highp float t = pos.y / height;</span>
<span class="s2">            t = (3.0 - 2.0 * t) * t * t;</span>
<span class="s2">            pos.x = mix(qt_Vertex.x, side * width, t * bend);</span>
<span class="s2">            gl_Position = qt_Matrix * pos;</span>
<span class="s2">        }&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You can use now the effect simply like this:</p>
<div class="highlight-qml notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nx">QtQuick</span> <span class="mf">2.5</span>

<span class="nx">Rectangle</span> <span class="p">{</span>
    <span class="k">width:</span> <span class="mi">480</span><span class="p">;</span> <span class="k">height:</span> <span class="mi">240</span>
    <span class="k">color:</span> <span class="s1">&#39;#1e1e1e&#39;</span>

    <span class="nx">GenieEffect</span> <span class="p">{</span>
        <span class="k">source:</span> <span class="nx">Image</span> <span class="p">{</span> <span class="k">source:</span> <span class="s1">&#39;assets/lighthouse.jpg&#39;</span> <span class="p">}</span>
        <span class="nx">MouseArea</span> <span class="p">{</span>
            <span class="k">anchors.fill:</span> <span class="nx">parent</span>
            <span class="k">onClicked:</span> <span class="nx">parent</span><span class="p">.</span><span class="nx">minimized</span> <span class="o">=</span> <span class="o">!</span><span class="nx">parent</span><span class="p">.</span><span class="nx">minimized</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We have simplified the code by removing our background rectangle and we assigned the image directly to the effect, instead of loading it inside a standalone image element.</p>
</div>
<div class="section" id="curtain-effect">
<h2>10.6. Curtain Effect<a class="headerlink" href="#curtain-effect" title="Permalink to this headline">¶</a></h2>
<p><div class="btn-group" role="group"><a class="btn btn-link btn-xs" href="https://github.com/qmlbook/qmlbook//new?labels=ch09&body=back-link%3A+ch10-shaders%2Fshaders.html%23curtain-effect"><i class="glyphicon glyphicon-plus"></i> Issue</a><a class="btn btn-link btn-xs" href="https://github.com/qmlbook/qmlbook/?labels=ch09&page=1&state=open"><i class="glyphicon glyphicon-search"></i> Issues</a></div></p><p>In the last example for custom shader effects, I would like to bring you the curtain effect. This effect was published first in May 2011 as part of <a class="reference external" href="http://labs.qt.nokia.com/2011/05/03/qml-shadereffectitem-on-qgraphicsview/">Qt labs for shader effects</a>.</p>
<div class="figure">
<img alt="../_images/curtain.png" src="../_images/curtain.png" />
</div>
<p>At that time I really loved these effects and the curtain effect was my favorite out of them. I just love how the curtain opens and hide the background object.</p>
<p>I took the code and adapted it towards Qt 5, which was straightforward. Also, I did some simplifications to be able to use it better for a showcase. So if you are interested in the full example, please visit the lab’s blog.</p>
<p>Just a little bot for the background, the curtain is actually an image called <em>fabric.jpg</em> and it is the source for a shader effect. The effect uses the vertex shader to swing the curtain and uses the fragment shader to provide some shades. Here is a simple diagram to make you hopefully better understand the code.</p>
<div class="figure">
<img alt="../_images/curtain_diagram.png" src="../_images/curtain_diagram.png" />
</div>
<p>The waved shades of the curtain are computed through a sin curve with 7 up/downs (7*PI=21.99…) on the width of the curtain. The other important part is the swing. The <em>topWidth</em> of the curtain is animated when the curtain is opened or closed. The <em>bottomWidth</em> follows the <em>topWidth</em> with a <em>SpringAnimation</em>. By this, we create the effect of the swinging bottom part of the curtain. The calculated <em>swing</em> provides the strength of this swing interpolated over the y-component of the vertexes.</p>
<p>The curtain effect is located in the <code class="docutils literal notranslate"><span class="pre">CurtainEffect.qml</span></code> component where the fabric image act as the texture source. There is nothing new on the use of shaders here, only a different way to manipulate the <em>gl_Position</em> in the vertex shader and the <em>gl_FragColor</em> in the fragment shader.</p>
<div class="highlight-qml notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nx">QtQuick</span> <span class="mf">2.5</span>

<span class="nx">ShaderEffect</span> <span class="p">{</span>
    <span class="k">anchors.fill:</span> <span class="nx">parent</span>

    <span class="k">mesh:</span> <span class="nx">GridMesh</span> <span class="p">{</span>
        <span class="k">resolution:</span> <span class="nx">Qt</span><span class="p">.</span><span class="nx">size</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">property</span> <span class="nx">real</span> <span class="k">topWidth:</span> <span class="nx">open</span><span class="o">?</span><span class="k">width:</span><span class="mi">20</span>
    <span class="nx">property</span> <span class="nx">real</span> <span class="k">bottomWidth:</span> <span class="nx">topWidth</span>
    <span class="nx">property</span> <span class="nx">real</span> <span class="k">amplitude:</span> <span class="mf">0.1</span>
    <span class="nx">property</span> <span class="nx">bool</span> <span class="k">open:</span> <span class="kc">false</span>
    <span class="nx">property</span> <span class="nx">variant</span> <span class="k">source:</span> <span class="nx">effectSource</span>

    <span class="nx">Behavior</span> <span class="nx">on</span> <span class="nx">bottomWidth</span> <span class="p">{</span>
        <span class="nx">SpringAnimation</span> <span class="p">{</span>
            <span class="k">easing.type:</span> <span class="nx">Easing</span><span class="p">.</span><span class="nx">OutElastic</span><span class="p">;</span>
            <span class="k">velocity:</span> <span class="mi">250</span><span class="p">;</span> <span class="k">mass:</span> <span class="mf">1.5</span><span class="p">;</span>
            <span class="k">spring:</span> <span class="mf">0.5</span><span class="p">;</span> <span class="k">damping:</span> <span class="mf">0.05</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">Behavior</span> <span class="nx">on</span> <span class="nx">topWidth</span> <span class="p">{</span>
        <span class="nx">NumberAnimation</span> <span class="p">{</span> <span class="k">duration:</span> <span class="mi">1000</span> <span class="p">}</span>
    <span class="p">}</span>


    <span class="nx">ShaderEffectSource</span> <span class="p">{</span>
        <span class="kd">id: effectSource</span>
        <span class="k">sourceItem:</span> <span class="nx">effectImage</span><span class="p">;</span>
        <span class="k">hideSource:</span> <span class="kc">true</span>
    <span class="p">}</span>

    <span class="nx">Image</span> <span class="p">{</span>
        <span class="kd">id: effectImage</span>
        <span class="k">anchors.fill:</span> <span class="nx">parent</span>
        <span class="k">source:</span> <span class="s2">&quot;assets/fabric.png&quot;</span>
        <span class="k">fillMode:</span> <span class="nx">Image</span><span class="p">.</span><span class="nx">Tile</span>
    <span class="p">}</span>

    <span class="k">vertexShader:</span> <span class="s2">&quot;</span>
<span class="s2">        attribute highp vec4 qt_Vertex;</span>
<span class="s2">        attribute highp vec2 qt_MultiTexCoord0;</span>
<span class="s2">        uniform highp mat4 qt_Matrix;</span>
<span class="s2">        varying highp vec2 qt_TexCoord0;</span>
<span class="s2">        varying lowp float shade;</span>

<span class="s2">        uniform highp float topWidth;</span>
<span class="s2">        uniform highp float bottomWidth;</span>
<span class="s2">        uniform highp float width;</span>
<span class="s2">        uniform highp float height;</span>
<span class="s2">        uniform highp float amplitude;</span>

<span class="s2">        void main() {</span>
<span class="s2">            qt_TexCoord0 = qt_MultiTexCoord0;</span>

<span class="s2">            highp vec4 shift = vec4(0.0, 0.0, 0.0, 0.0);</span>
<span class="s2">            highp float swing = (topWidth - bottomWidth) * (qt_Vertex.y / height);</span>
<span class="s2">            shift.x = qt_Vertex.x * (width - topWidth + swing) / width;</span>

<span class="s2">            shade = sin(21.9911486 * qt_Vertex.x / width);</span>
<span class="s2">            shift.y = amplitude * (width - topWidth + swing) * shade;</span>

<span class="s2">            gl_Position = qt_Matrix * (qt_Vertex - shift);</span>

<span class="s2">            shade = 0.2 * (2.0 - shade ) * ((width - topWidth + swing) / width);</span>
<span class="s2">        }&quot;</span>

    <span class="k">fragmentShader:</span> <span class="s2">&quot;</span>
<span class="s2">        uniform sampler2D source;</span>
<span class="s2">        varying highp vec2 qt_TexCoord0;</span>
<span class="s2">        varying lowp float shade;</span>
<span class="s2">        void main() {</span>
<span class="s2">            highp vec4 color = texture2D(source, qt_TexCoord0);</span>
<span class="s2">            color.rgb *= 1.0 - shade;</span>
<span class="s2">            gl_FragColor = color;</span>
<span class="s2">        }&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The effect is used in the <code class="docutils literal notranslate"><span class="pre">curtaindemo.qml</span></code> file.</p>
<div class="highlight-qml notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nx">QtQuick</span> <span class="mf">2.5</span>

<span class="nx">Item</span> <span class="p">{</span>
    <span class="kd">id: root</span>
    <span class="k">width:</span> <span class="nx">background</span><span class="p">.</span><span class="nx">width</span><span class="p">;</span> <span class="k">height:</span> <span class="nx">background</span><span class="p">.</span><span class="nx">height</span>


    <span class="nx">Image</span> <span class="p">{</span>
        <span class="kd">id: background</span>
        <span class="k">anchors.centerIn:</span> <span class="nx">parent</span>
        <span class="k">source:</span> <span class="s1">&#39;assets/background.png&#39;</span>
    <span class="p">}</span>

    <span class="nx">Text</span> <span class="p">{</span>
        <span class="k">anchors.centerIn:</span> <span class="nx">parent</span>
        <span class="k">font.pixelSize:</span> <span class="mi">48</span>
        <span class="k">color:</span> <span class="s1">&#39;#efefef&#39;</span>
        <span class="k">text:</span> <span class="s1">&#39;Qt5 Cadaques&#39;</span>
    <span class="p">}</span>

    <span class="nx">CurtainEffect</span> <span class="p">{</span>
        <span class="kd">id: curtain</span>
        <span class="k">anchors.fill:</span> <span class="nx">parent</span>
    <span class="p">}</span>

    <span class="nx">MouseArea</span> <span class="p">{</span>
        <span class="k">anchors.fill:</span> <span class="nx">parent</span>
        <span class="k">onClicked:</span> <span class="nx">curtain</span><span class="p">.</span><span class="nx">open</span> <span class="o">=</span> <span class="o">!</span><span class="nx">curtain</span><span class="p">.</span><span class="nx">open</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The curtain is opened through a custom <em>open</em> property on the curtain effect. We use a <em>MouseArea</em> to trigger the opening and closing of the curtain.</p>
</div>
<div class="section" id="qt-graphicseffect-library">
<h2>10.7. Qt GraphicsEffect Library<a class="headerlink" href="#qt-graphicseffect-library" title="Permalink to this headline">¶</a></h2>
<p><div class="btn-group" role="group"><a class="btn btn-link btn-xs" href="https://github.com/qmlbook/qmlbook//new?labels=ch09&body=back-link%3A+ch10-shaders%2Fshaders.html%23qt-graphicseffect-library"><i class="glyphicon glyphicon-plus"></i> Issue</a><a class="btn btn-link btn-xs" href="https://github.com/qmlbook/qmlbook/?labels=ch09&page=1&state=open"><i class="glyphicon glyphicon-search"></i> Issues</a></div></p><p>The graphics effect library is a collection of shader effects. Ready-made by the Qt developers. It’s a great tool-set to be used in your application but also a great source to learn how to build shaders.</p>
<p>The graphics effects library comes with a so-called manual testbed which is a great tool to interactively discover the different effects.</p>
<p>The testbed is located under <code class="docutils literal notranslate"><span class="pre">$QTDIR/qtgraphicaleffects/tests/manual/testbed</span></code>.</p>
<div class="figure">
<img alt="../_images/graphicseffectstestbed.png" src="../_images/graphicseffectstestbed.png" />
</div>
<p>The effects library contains ca 20 effects. A list of the effect and a short description can be found below.</p>
<p class="rubric">Graphics Effects List</p>
<table border="1" class="colwidths-given docutils" id="id1">
<caption><span class="caption-text">Graphics Effects List</span><a class="headerlink" href="#id1" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="27%" />
<col width="18%" />
<col width="55%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Category</th>
<th class="head">Effect</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Blend</td>
<td><em>Blend</em></td>
<td>merges two source items by using a blend mode</td>
</tr>
<tr class="row-odd"><td>Color</td>
<td><em>BrightnessContrast</em></td>
<td>adjusts brightness and contrast</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td><em>Colorize</em></td>
<td>sets color in the HSL color space</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td><em>ColorOverlay</em></td>
<td>applies a color layer</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td><em>Desaturate</em></td>
<td>reduces color saturation</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td><em>GammaAdjust</em></td>
<td>adjusts luminance</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td><em>HueSaturation</em></td>
<td>adjusts colors in the HSL color space</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td><em>LevelAdjust</em></td>
<td>adjusts colors in the RGB color space</td>
</tr>
<tr class="row-even"><td>Gradient</td>
<td><em>ConicalGradient</em></td>
<td>draws a conical gradient</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td><em>LinearGradient</em></td>
<td>draws a linear gradient</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td><em>RadialGradient</em></td>
<td>draws a radial gradient</td>
</tr>
<tr class="row-odd"><td>Distortion</td>
<td><em>Displace</em></td>
<td>moves the pixels of the source item according to the specified displacement source</td>
</tr>
<tr class="row-even"><td>Drop Shadow</td>
<td><em>DropShadow</em></td>
<td>draws a drop shadow</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td><em>InnerShadow</em></td>
<td>draws an inner shadow</td>
</tr>
<tr class="row-even"><td>Blur</td>
<td><em>FastBlur</em></td>
<td>applies a fast blur effect</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td><em>GaussianBlur</em></td>
<td>applies a higher quality blur effect</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td><em>MaskedBlur</em></td>
<td>applies a varying intensity blur effect</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td><em>RecursiveBlur</em></td>
<td>blurs repeatedly, providing a strong blur effect</td>
</tr>
<tr class="row-even"><td>Motion Blur</td>
<td><em>DirectionalBlur</em></td>
<td>applies a directional motion blur effect</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td><em>RadialBlur</em></td>
<td>applies a radial motion blur effect</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td><em>ZoomBlur</em></td>
<td>applies a zoom motion blur effect</td>
</tr>
<tr class="row-odd"><td>Glow</td>
<td><em>Glow</em></td>
<td>draws an outer glow effect</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td><em>RectangularGlow</em></td>
<td>draws a rectangular outer glow effect</td>
</tr>
<tr class="row-odd"><td>Mask</td>
<td><em>OpacityMask</em></td>
<td>masks the source item with another item</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td><em>ThresholdMask</em></td>
<td>masks the source item with another item and applies a threshold value</td>
</tr>
</tbody>
</table>
<p>Here is a example using the <em>FastBlur</em> effect from the <em>Blur</em> category:</p>
<div class="highlight-qml notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nx">QtQuick</span> <span class="mf">2.5</span>
<span class="kr">import</span> <span class="nx">QtGraphicalEffects</span> <span class="mf">1.0</span>

<span class="nx">Rectangle</span> <span class="p">{</span>
    <span class="k">width:</span> <span class="mi">480</span><span class="p">;</span> <span class="k">height:</span> <span class="mi">240</span>
    <span class="k">color:</span> <span class="s1">&#39;#1e1e1e&#39;</span>

    <span class="nx">Row</span> <span class="p">{</span>
        <span class="k">anchors.centerIn:</span> <span class="nx">parent</span>
        <span class="k">spacing:</span> <span class="mi">16</span>

        <span class="nx">Image</span> <span class="p">{</span>
            <span class="kd">id: sourceImage</span>
            <span class="k">source:</span> <span class="s2">&quot;assets/tulips.jpg&quot;</span>
            <span class="k">width:</span> <span class="mi">200</span><span class="p">;</span> <span class="k">height:</span> <span class="nx">width</span>
            <span class="k">sourceSize:</span> <span class="nx">Qt</span><span class="p">.</span><span class="nx">size</span><span class="p">(</span><span class="nx">parent</span><span class="p">.</span><span class="nx">width</span><span class="p">,</span> <span class="nx">parent</span><span class="p">.</span><span class="nx">height</span><span class="p">)</span>
            <span class="k">smooth:</span> <span class="kc">true</span>
        <span class="p">}</span>

        <span class="nx">FastBlur</span> <span class="p">{</span>
            <span class="k">width:</span> <span class="mi">200</span><span class="p">;</span> <span class="k">height:</span> <span class="nx">width</span>
            <span class="k">source:</span> <span class="nx">sourceImage</span>
            <span class="k">radius:</span> <span class="nx">blurred</span><span class="o">?</span><span class="mi">32</span><span class="o">:</span><span class="mi">0</span>
            <span class="nx">property</span> <span class="nx">bool</span> <span class="k">blurred:</span> <span class="kc">false</span>

            <span class="nx">Behavior</span> <span class="nx">on</span> <span class="nx">radius</span> <span class="p">{</span>
                <span class="nx">NumberAnimation</span> <span class="p">{</span> <span class="k">duration:</span> <span class="mi">1000</span> <span class="p">}</span>
            <span class="p">}</span>

            <span class="nx">MouseArea</span> <span class="p">{</span>
                <span class="kd">id: area</span>
                <span class="k">anchors.fill:</span> <span class="nx">parent</span>
                <span class="k">onClicked:</span> <span class="nx">parent</span><span class="p">.</span><span class="nx">blurred</span> <span class="o">=</span> <span class="o">!</span><span class="nx">parent</span><span class="p">.</span><span class="nx">blurred</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The image to the left is the original image. Clicking the image on the right will toggle blurred property and animated the blur radius from 0 to 32 during 1 second. The image on the left shows the blurred image.</p>
<div class="figure">
<img alt="../_images/fastblur.png" src="../_images/fastblur.png" />
</div>
</div>
</div>


    </div>
      
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2012-2018 Jürgen Bocklage-Ryannel and Johan Thelin. This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.<br/>
      Last updated on Jul 18, 2020.<br/>
    </p>
  </div>
</footer>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-46104829-1', 'auto');
  ga('send', 'pageview');

</script>

  </body>
</html>